---
title: Final Prediction
author: Avi Agarwal
date: '2024-11-04'
slug: final-prediction
categories: []
tags: []
---
```{r , echo= FALSE, message = FALSE, warning=FALSE}
library(tidyverse)
library(knitr)
library(sjPlot)
library(plotly)
library(maps)
library(car)
library(CVXR)
library(stringr)
library(knitr)
library(kableExtra)
set.seed(02138)

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_polls <- read_csv("state_polls_1968-2024(1).csv")
swing_states <- c("Florida", "Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_polls_dem <- swing_state_polls |>
  filter(state %in% swing_states & weeks_left < 11 & weeks_left >= 1) |>
  
  group_by(state, year, weeks_left, party) |>
  summarize(avg_support = mean(poll_support), .groups = "drop") |>
  
  pivot_wider(names_from = party, values_from = avg_support, names_prefix = "support_") |>
  
  mutate(
    margin = support_DEM - support_REP
  ) |>
  
  pivot_wider(
    names_from = weeks_left, 
    values_from = c(support_DEM, support_REP, margin)
  ) |>
  
  mutate(
    polling_trend_5_1 = margin_1 - margin_5,
    polling_trend_10_6 = margin_6 - margin_10,
    average_polling = rowMeans(across(starts_with("margin_")), na.rm = TRUE),
    current_week = margin_1
  ) |>
  
  na.omit() |>
  
  select(year, state, support_DEM_1,support_DEM_3, support_DEM_2,support_REP_1, polling_trend_5_1, polling_trend_10_6, average_polling, current_week)

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
state_dpi <- read_csv("Table.csv") 
state_dpi[, 28:77] <- lapply(state_dpi[, 28:77], as.numeric)
state_dpi <- state_dpi %>% select(-c(3:27))
state_dpi <- state_dpi |> 
  mutate(state = GeoName) |>
  select(-GeoName, -GeoFips) 

```


```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_state_dpi <- state_dpi |>
  filter(state %in% swing_states) |>
  pivot_longer(cols = `1974`:`2023`, names_to = "year", values_to = "percent_change_dpi") |>
  mutate(year = as.numeric(year)) |>
  mutate(election_year = year + 1) |>
  filter(election_year %% 4 == 0) |>
  select(-year) |>
  rename(year = election_year) 
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
yearly_inflation <- read_csv("yearly_inflation.csv")
yearly_inflation <- yearly_inflation |> 
  select(-c(1:4)) |>
  pivot_longer(cols = 1:64, names_to = "year", values_to = "yearly_national_inflation")

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
yearly_inflation <- yearly_inflation |> 
  mutate(year = as.numeric(year)) |>
  mutate(year = year + 1) |>
  mutate(yearly_national_inflation = as.numeric(yearly_national_inflation)) 
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_dpi<- swing_state_dpi |>
  left_join(yearly_inflation, by = "year") |>
  mutate(dpi_inflation_adjusted = percent_change_dpi - yearly_national_inflation) |>
  select(-percent_change_dpi, -yearly_national_inflation)
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_data <- swing_state_polls_dem |>
  left_join(swing_state_dpi, by = c("year","state")) |>
  na.omit()
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
state_pop_vote <- read_csv("state_popvote_1948_2020.csv") 
state_pop_vote_dem <- state_pop_vote |>
  filter(state %in% swing_states) |>
  select(c( year, state,D_pv2p, D_pv2p_lag1, D_pv2p_lag2)) 

  
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_data <- swing_state_data |>
  left_join(state_pop_vote_dem, by = c("year", "state"))
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
nat_pop_vote <- read_csv("popvote_1948_2020.csv") |>
  filter(party == "democrat") |> 
  select(year, incumbent_party) |>
  mutate(incumbent_party = ifelse(incumbent_party == TRUE, 1, 0))
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_data <- swing_state_data |>
  left_join(nat_pop_vote, by = "year")
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
fred_econ <- read_csv("fred_econ.csv") 
fred_adjusted <- fred_econ |>
  filter(year > 1958) |>
  mutate(unemployment_growth_quarterly = (unemployment - lag(unemployment, 1)) / lag(unemployment, 1) * 100) |>
  filter(quarter == 2) |>
  mutate(sp500_growth_quarterly = ((sp500_adj_close - sp500_open)) / sp500_open * 100) |>
  filter(year >= 1960)
         
data_2020 <- fred_adjusted |>
  filter(year == 2020 | year == 2019) |>
  mutate(RDPI_growth_quarterly =  lag(RDPI_growth_quarterly, 1), unemployment_growth_quarterly =  lag(unemployment_growth_quarterly, 1)) |>
  filter(year == 2020)

fred_adjusted <- fred_adjusted |>
  filter(year != 2020) |>
  bind_rows(data_2020) |>
  filter(year %% 4 == 0) |>
  select(year, RDPI_growth_quarterly,sp500_growth_quarterly, unemployment_growth_quarterly) 

```


```{r , echo= FALSE, message = FALSE, warning=FALSE}
 swing_state_data <-  swing_state_data |>
  left_join(fred_adjusted, by = "year")
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
updated_rdpi <- read.csv("DSPIC96.csv")

updated_rdpi$DATE <- as.Date(updated_rdpi$DATE, format = "%m/%d/%Y")

updated_rdpi$Year <- format(updated_rdpi$DATE, "%Y")
updated_rdpi$Month <- format(updated_rdpi$DATE, "%B")  # %B for full month name

updated_rdpi <- updated_rdpi[, !(names(updated_rdpi) %in% "DATE")]

updated_rdpi <- updated_rdpi %>%
  mutate(Year = as.numeric(Year)) %>% 
  filter((Month == "June" | Month == "September") & Year %% 4 == 0) %>%
  group_by(Year) %>% 
  pivot_wider(names_from = Month, values_from = DSPIC96) %>%
  ungroup() %>%
  mutate(updated_rdpi = ((September - June) / June) * 100) |> 
  mutate(year = Year) |>
  select(year,updated_rdpi )

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_data <-  swing_state_data |>
  left_join(updated_rdpi, by = "year") |>
  filter(year != 1976)
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
twentyfour_lags <- state_pop_vote |>
  filter(year == 2020) |>
   mutate(D_pv2p_lag2= D_pv2p_lag1,
     D_pv2p_lag1 = D_pv2p,
     year = 2024) |>
  select(-D_pv2p)

swing_state_data_test <- swing_state_data |>
  filter(year == 2024) |>
  select(where(~ !all(is.na(.)))) |>
  left_join(twentyfour_lags, by = c("state", "year")) 
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

state_weights <- list()
predictions_2024 <- list()


c <- 3  

for (state_name in swing_states) {
  
 # print(state_name)
  
  
  n_state_data <- swing_state_data |>
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == state_name) |>
    filter(year != 2024)
  
  state_data <- n_state_data |>
    filter(state != "AAFlorida")
  
  fl_data <- n_state_data |>
    filter(state == "AAFlorida")
  
  individual_predictions <- matrix(NA, nrow = nrow(state_data), ncol = c)
  true_values <- state_data$D_pv2p
  
  
  for (i in 1:nrow(state_data)) {
    
    d_train_data <- state_data[-i, ]
    d_test_data <- state_data[i, , drop = FALSE]
    
    #print(d_test_data$state)
    #print(d_test_data$year)
    #print(d_test_data$D_pv2p)
    
    test_year <- d_test_data$year
    
    train_data <- bind_rows(d_train_data, fl_data) |>
      filter(year != test_year )
    
    
    test_data <- bind_rows(d_test_data, fl_data) |>
      filter(year == test_year)  |>
      arrange(desc(state == "AAFlorida"))
  
 
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = train_data)
      
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = train_data)
    
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1  + D_pv2p_lag2 + support_DEM_1 +  polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = train_data)
    
    
    individual_predictions[i, 1] <- predict(mod_1, newdata = test_data)[2]
    individual_predictions[i, 2] <- predict(mod_2, newdata = test_data)[2]
    individual_predictions[i, 3] <- predict(mod_3, newdata = test_data)[2]
    
    #print(individual_predictions[i, ])
    
    
  }
  
  
  train_data <- swing_state_data |> 
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == state_name) |>
    filter(year != 2024)
  
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = train_data)
      
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = train_data)
    
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1  + D_pv2p_lag2 + support_DEM_1 +  polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = train_data)
    
  
  
  y_test <- true_values
  
  w <- lm(y_test ~ individual_predictions - 1) 
  
  initial_weights <- coef(w)
  
  beta <- Variable(c)  
  objective <- Minimize(sum_squares(y_test - individual_predictions %*% beta))
  
  prob <- Problem(objective)
  constraints(prob) <- list(beta >= 0, beta <= 1, sum(beta) == 1)  
  solution_prob <- solve(prob)
  weights_dem <- solution_prob$getValue(beta)
  
  #print(weights_dem)
  
  
  state_weights[[state_name]] <- weights_dem
  
  state_test_data_2024 <- swing_state_data_test |>
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == state_name) |> 
    arrange(desc(state == "AAFlorida"))
  
  pred_1_2024 <- as.numeric(predict(mod_1, newdata = state_test_data_2024))
  pred_2_2024 <- as.numeric(predict(mod_2, newdata = state_test_data_2024))
  pred_3_2024 <- as.numeric(predict(mod_3, newdata = state_test_data_2024))
  
  predictions_matrix_2024 <- cbind(pred_1_2024, pred_2_2024, pred_3_2024)
  #print(predictions_matrix_2024)
  
  weights_dem <- state_weights[[state_name]]
  prediction_2024 <- as.vector(predictions_matrix_2024[2, ] %*% weights_dem)
  
  predictions_2024[[state_name]] <- data.frame(state = state_name, prediction_2024 = prediction_2024)
}

predictions_2024_df <- do.call(rbind, predictions_2024)
#predictions_2024_df

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
weights_df <- do.call(rbind, lapply(swing_states, function(state_name) {
  data.frame(
    State = state_name,
    `Weight Model 1` = state_weights[[state_name]][1],
    `Weight Model 2` = state_weights[[state_name]][2],
    `Weight Model 3` = state_weights[[state_name]][3]
  )
}))

# Display the table using kable for nicely formatted output
weights <- weights_df %>%
  kable("html", caption = "Model Weights by State", digits = 4) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  column_spec(1, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(2:4, width = "6em", extra_css = "text-align: center;")
```


```{r , echo= FALSE, message = FALSE, warning=FALSE}
mse_results <- list()

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")



for (i in swing_states) {
  
  #print(i)
  
  train_data <- swing_state_data |> 
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == i) |>
    filter(year != 2024)
  
  state_test_data_2020 <- swing_state_data |>
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == i) |>
    filter (year == 2020)
  

  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = train_data)
      
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = train_data)
    
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1  + D_pv2p_lag2 + support_DEM_1 +  polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = train_data)
    
    
  

  pred_1 <- as.numeric(predict(mod_1, newdata = state_test_data_2020))[2]
  pred_2 <- as.numeric(predict(mod_2, newdata = state_test_data_2020))[2]
  pred_3 <- as.numeric(predict(mod_3, newdata = state_test_data_2020))[2]
  
  predictions <- cbind(pred_1, pred_2, pred_3)
#  print(predictions)
  weights_dem <- state_weights[[i]]
  #print(weights_dem)
  

  prediction_dem <- as.vector(predictions %*% weights_dem)
  
  
  state_test_data_2020 <- state_test_data_2020 |>
    filter(state == i)
  
  #print("real")
  #print(state_test_data_2020$D_pv2p)

  
 # print("one model")
  #print(prediction_dem)
  rmse_dem_1 <- sqrt(mean((state_test_data_2020$D_pv2p - prediction_dem)^2))

  #print(rmse_dem_1)
  

  actual_winner <- ifelse(state_test_data_2020$D_pv2p > 50, "Democrat", "Republican")
  predicted_winner <- ifelse(prediction_dem > 50, "Democrat", "Republican")

#if (actual_winner == predicted_winner) {
#  print("Correct prediction: Model correctly predicted the winner!")
#} else {
#  print("Incorrect prediction: Model did not predict the correct winner.")
#}
  
  mse_results[[i]] <- rmse_dem_1
  
  
}

rmse_df <- data.frame(
  State = names(mse_results),
  `RMSE 2020` = unlist(mse_results)
)

# Display the table using kable for nicely formatted output
in_rmse <- rmse_df %>%
  kable("html", caption = "In-Sample RMSE for 2020 by State",row.names = FALSE, digits = 4) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  column_spec(1, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(2, width = "6em", extra_css = "text-align: center;")

```


```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

rmse_results <- list()

for (i in swing_states) {
  
  #print(i)
  
  train_data <- swing_state_data |> 
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == i) |>
    filter(year != 2020 & year != 2024)
  
  state_test_data_2020 <- swing_state_data |>
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == i) |>
    filter (year == 2020)
  
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = train_data)
      
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = train_data)
    
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1  + D_pv2p_lag2 + support_DEM_1 +  polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = train_data)
    
    
  

  pred_1 <- as.numeric(predict(mod_1, newdata = state_test_data_2020))[2]
  pred_2 <- as.numeric(predict(mod_2, newdata = state_test_data_2020))[2]
  pred_3 <- as.numeric(predict(mod_3, newdata = state_test_data_2020))[2]
  
  predictions <- cbind(pred_1, pred_2, pred_3)
#  print(predictions)
  weights_dem <- state_weights[[i]]
  #print(weights_dem)
  #

  prediction_dem <- as.vector(predictions %*% weights_dem)
  
  
  state_test_data_2020 <- state_test_data_2020 |>
    filter(state == i)
  
  #print("real")
  #print(state_test_data_2020$D_pv2p)

  
 # print("one model")
  #print(prediction_dem)
  rmse_dem_1 <- sqrt(mean((state_test_data_2020$D_pv2p - prediction_dem)^2))
  
  rmse_results[[i]] <- rmse_dem_1

  #print(rmse_dem_1)
  

  actual_winner <- ifelse(state_test_data_2020$D_pv2p > 50, "Democrat", "Republican")
  predicted_winner <- ifelse(prediction_dem > 50, "Democrat", "Republican")

#if (actual_winner == predicted_winner) {
#  print("Correct prediction: Model correctly predicted the winner!")
#} else {
#  print("Incorrect prediction: Model did not predict the correct winner.")
#}
  
  

}

rmse_df <- data.frame(
  State = names(rmse_results),
  `RMSE 2020` = unlist(rmse_results)
)

# Display the table using kable for nicely formatted output
out_rmse <- rmse_df %>%
  kable("html", caption = "Out-of-Sample RMSE for 2020 by State", row.names = FALSE, digits = 4) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  column_spec(1, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(2, width = "6em", extra_css = "text-align: center;")
  
  
```



```{r , echo= FALSE, message = FALSE, warning=FALSE}

state_pop_vote_1 <- state_pop_vote |>
  filter(state != swing_states & year == 2020) |>
  mutate(margin = D_pv2p - R_pv2p) |>
  select(state, margin) 

ensemble_pred <- predictions_2024_df |>
  mutate(adj_dem_vote = prediction_2024,
         adj_rep_vote = 100 - prediction_2024,
         Margin = adj_dem_vote - adj_rep_vote,
         sum = adj_dem_vote + adj_rep_vote) |>
  filter(state %in% swing_states) |>
  select(state,Margin) 

 ensemble_pred_table <- ensemble_pred %>%
  mutate(Margin = paste0(round(Margin, 2), "%")) %>%   
  rename(State = state)  


e_pred <- ensemble_pred_table %>%
  select(State, Margin) %>%
  kable("html", caption = "Ensemble Model Predicted Vote Share", row.names = FALSE) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  column_spec(1, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(2, width = "8em", extra_css = "text-align: center;")



pred_2024 <- bind_rows(ensemble_pred, state_pop_vote_1)
  
#write_csv(pred_2024, "avi_2024_pred.csv")

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_state_data_dems <- ensemble_pred %>%
  mutate(state = tolower(state)) 

us_states <- map_data("state")


swing_map_data <- us_states %>%
  filter(region %in% swing_state_data_dems$state) %>%
  left_join(swing_state_data_dems, by = c("region" = "state"))

swing_map_data <- swing_map_data %>%
  distinct(region, .keep_all = TRUE) %>%
  mutate(state = tools::toTitleCase(region)) %>%
  mutate(state_code = state.abb[match(state, state.name)]) |>
  mutate(region = tools::toTitleCase(region))

map_plot <- plot_ly(
  data = swing_map_data,
  type = "choropleth",
  locations = ~state_code,
  locationmode = "USA-states",
  z = ~Margin,
  text = ~paste("State:", region, "<br>Margin:", round(Margin, 2), "%"),
  hoverinfo = "text",
  colorscale = list(c(0, "darkred"), c(0.5, "white"), c(1, "blue")),
  zmin = -10,   
  zmid = 0,     
  zmax = 10,    
  colorbar = list(
    title = "Dem. Voting Margin (%)",
    y = 0.5,           
    yanchor = "middle" 
  )
) %>%
  layout(
    title = list(
      text = "2024 Swing State Voting Margins",
      y = 0.95,
      x = 0.5,
      xanchor = "center",
      yanchor = "top"
    ),
    geo = list(
      scope = "usa",
      projection = list(type = "albers usa"),
      showlakes = FALSE,
      showcountries = FALSE,
      showcoastlines = FALSE,
      coastlinecolor = toRGB("white"),
      showframe = FALSE
    )
  )
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

num_samples <- 1000

swing_state_polls_dem <- swing_state_polls |>
  filter(state %in% swing_states & weeks_left < 11 & weeks_left >= 1) |>
  
  group_by(state, year, weeks_left, party) |>
  summarize(avg_support = mean(poll_support), .groups = "drop") |>
  
  pivot_wider(names_from = party, values_from = avg_support, names_prefix = "support_") |>
  
  mutate(
    margin = support_DEM - support_REP
  ) |>
  
  pivot_wider(
    names_from = weeks_left, 
    values_from = c(support_DEM, support_REP, margin)
  ) |>
  
  mutate(
    polling_trend_5_1 = margin_1 - margin_5,
    polling_trend_10_6 = margin_6 - margin_10,
    average_polling = rowMeans(across(starts_with("margin_")), na.rm = TRUE),
    current_week = margin_1
  ) |>
  
  na.omit() 


swing_state_data_sim <- swing_state_polls_dem %>%
  filter(year == 2024) %>%
  group_by(state) %>%
  summarize(
    polling_trend_5_1_mean = mean(polling_trend_5_1),
    polling_trend_10_6_mean = mean(polling_trend_10_6),
    current_week_mean = mean(current_week),
    support_DEM_1_mean = mean(support_DEM_1),
    support_DEM_2_mean = mean(support_DEM_2),
    support_DEM_3_mean = mean(support_DEM_3),
    support_REP_1_mean = mean(support_REP_1),
    .groups = 'drop'
  )

polling_error_sd <- 3


simulated_data <- swing_state_data_sim %>%
  rowwise() %>%
  mutate(
    polling_trend_5_1_sim = list(rnorm(num_samples, mean = polling_trend_5_1_mean, sd = polling_error_sd)),
    polling_trend_10_6_sim = list(rnorm(num_samples, mean = polling_trend_10_6_mean, sd = polling_error_sd)),
    current_week_sim = list(rnorm(num_samples, mean = current_week_mean, sd = polling_error_sd)),
    support_DEM_1_sim = list(rnorm(num_samples, mean = support_DEM_1_mean, sd = polling_error_sd)),
    support_DEM_2_sim = list(rnorm(num_samples, mean = support_DEM_2_mean, sd = polling_error_sd)),
    support_DEM_3_sim = list(rnorm(num_samples, mean = support_DEM_3_mean, sd = polling_error_sd)),
    support_REP_1_sim = list(rnorm(num_samples, mean = support_REP_1_mean, sd = polling_error_sd))
  ) %>%
  unnest(c(polling_trend_5_1_sim, polling_trend_10_6_sim, current_week_sim, support_DEM_1_sim, support_REP_1_sim)) |>
  rename(
    polling_trend_5_1 = polling_trend_5_1_sim,
    polling_trend_10_6 = polling_trend_10_6_sim,
    current_week = current_week_sim,
    support_DEM_1 = support_DEM_1_sim,
    support_DEM_2 = support_DEM_2_sim,
    support_DEM_3 = support_DEM_3_sim,
    support_REP_1 = support_REP_1_sim
  ) |>
  mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
  select(state, polling_trend_5_1, polling_trend_10_6, current_week, support_DEM_1, support_REP_1)

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
num_simulations <- 1000

simulation_results <- list()

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

electoral_votes <- c("Arizona" = 11, "Georgia" = 16, "Michigan" = 15, 
                     "Nevada" = 6, "North Carolina" = 16, "Pennsylvania" = 19, "Wisconsin" = 10, 
                     "AAFlorida" = 0) #assuming dems. never win FL

base_electoral_votes <- 226

total_electoral_votes <- numeric(num_simulations)  


for (state_name in swing_states) {
  
  state_data <- swing_state_data |> 
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == state_name) |>
    filter(year != 2024)
  
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = state_data)
      
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = state_data)
    
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1  + D_pv2p_lag2 + support_DEM_1 +  polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = state_data)
  
  fl_state_data <- swing_state_data_test |>
    filter(state == "Florida") |>
    mutate(state = "AAFlorida")

  for (i in 1:num_simulations) {
    
    sim_poll <- simulated_data %>%
      filter(state == state_name) %>%
      slice(i) %>%
      select(state, polling_trend_5_1, polling_trend_10_6, current_week, support_DEM_1, support_REP_1)
    
  
    state_test_data <- swing_state_data_test |>
      filter(state == state_name) |>
      select(-c(polling_trend_5_1, polling_trend_10_6, current_week, support_DEM_1, support_REP_1))
    
    state_test_data <- state_test_data |>
      left_join(sim_poll, by = "state") 
    
    test_data <- bind_rows(state_test_data, fl_state_data)
    
  
    pred_1 <- predict(mod_1, newdata = test_data)[1]
    pred_2 <- predict(mod_2, newdata = test_data)[1]
    pred_3 <- predict(mod_3, newdata = test_data)[1]
    

    weights_dem <- state_weights[[state_name]]
    prediction <- as.vector(c(pred_1, pred_2, pred_3) %*% weights_dem)

    if (prediction > 50) {
      total_electoral_votes[i] <- total_electoral_votes[i] + electoral_votes[state_name]
    }
  }
}


total_electoral_votes <- total_electoral_votes + base_electoral_votes


electoral_vote_counts <- table(total_electoral_votes)

electoral_vote_df <- data.frame(
  electoral_votes = as.numeric(names(electoral_vote_counts)),
  count = as.numeric(electoral_vote_counts)
)


```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
expanded_data <- electoral_vote_df %>%
  mutate(count = round(count * 0.2)) %>%  
  uncount(count) %>% 
  mutate(color = ifelse(electoral_votes >= 270, "steelblue", "red"))


sim_plot <- ggplot(expanded_data, aes(x = electoral_votes, fill = color)) +
  geom_dotplot(binwidth = 2, dotsize = 0.5, stackdir = "up", stroke = 0) +
  scale_x_continuous(breaks = seq(0, 538, by = 10), limits = c(220, 310)) +
  scale_fill_identity() + 
  labs(
    title = "Simulated Electoral College Outcomes",
    subtitle = "Each dot represents five simulation results",
    x = "Harris Electoral Vote Total",
    y = "Frequency (stacked dots)"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()
  ) +
  geom_vline(xintercept = 270, color = "black", linetype = "dashed", alpha = 0.7)
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}

total_simulations <- 1000


win_counts <- electoral_vote_df %>%
  filter(electoral_votes >= 270) %>%
  summarize(
    `Harris Victory Wins` = sum(count),
    `Trump Victory Wins` = total_simulations - sum(count),
    `Harris Victory %` = paste0(round((sum(count) / total_simulations) * 100, 2), "%")
  )

sim_table <- win_counts %>%
  kable("html", caption = "Simulation Results: Harris and Trump Victory Counts") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive"), position = "center") %>%
  column_spec(1, width = "5em", extra_css = "text-align: center;") %>%
  column_spec(2, width = "5em", extra_css = "text-align: center;") %>%
  column_spec(3, width = "5em", extra_css = "text-align: center;")

```


# Model Equations


1. Model 1:
$$
\begin{aligned}
D\_pv2p = & \, \alpha + \beta_1(\text{state}) + \beta_2(\text{D\_pv2p\_lag1}) + \beta_3(\text{D\_pv2p\_lag2}) \\
& + \beta_4(\text{updated\_rdpi} \times \text{incumbent\_party}) + \beta_5(\text{dpi\_inflation\_adjusted} \times \text{incumbent\_party}) + \epsilon
\end{aligned}
$$

2. Model 2:
  $$
\begin{aligned}
D\_pv2p = & \, \alpha + \beta_1(\text{state}) + \beta_2(\text{polling\_trend\_5\_1}) + \beta_3(\text{polling\_trend\_10\_6}) \\
& + \beta_4(\text{current\_week}) + \beta_5(\text{support\_DEM\_1}) + \beta_6(\text{support\_DEM\_2}) + \beta_7(\text{support\_DEM\_3}) + \epsilon
\end{aligned}
  $$

3. Model 3:

  $$
\begin{aligned}
D\_pv2p = & \, \alpha + \beta_1(\text{state}) + \beta_2(\text{D\_pv2p\_lag1}) + \beta_3(\text{D\_pv2p\_lag2}) + \beta_4(\text{support\_DEM\_1}) \\
& + \beta_5(\text{polling\_trend\_5\_1}) + \beta_6(\text{polling\_trend\_10\_6}) + \beta_7(\text{dpi\_inflation\_adjusted} \times \text{incumbent\_party}) \\
& + \beta_8(\text{unemployment\_growth\_quarterly} \times \text{incumbent\_party}) + \beta_9(\text{updated\_rdpi} \times \text{incumbent\_party}) + \epsilon
\end{aligned}
  $$

# Weights

```{r , echo= FALSE, message = FALSE, warning=FALSE}
weights

```


# RMSE (In-sample & Out-of-sample)

```{r , echo= FALSE, message = FALSE, warning=FALSE}
in_rmse
```


```{r , echo= FALSE, message = FALSE, warning=FALSE}
out_rmse
```


# Ensemble Model Predictions
```{r , echo= FALSE, message = FALSE, warning=FALSE}
e_pred
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
map_plot
```

# Simulations
```{r , echo= FALSE, message = FALSE, warning=FALSE}
sim_plot
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
sim_table
```

