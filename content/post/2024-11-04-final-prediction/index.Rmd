---
title: Final Prediction
author: Avi Agarwal
date: '2024-11-04'
slug: final-prediction
categories: []
tags: []
---
```{r , echo= FALSE, message = FALSE, warning=FALSE}
library(tidyverse)
library(knitr)
library(sjPlot)
library(plotly)
library(maps)
library(car)
library(CVXR)
library(stringr)
library(knitr)
library(kableExtra)
set.seed(02138)

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_polls <- read_csv("state_polls_1968-2024(1).csv")
swing_states <- c("Florida", "Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_polls_dem <- swing_state_polls |>
  filter(state %in% swing_states & weeks_left < 11 & weeks_left >= 1) |>
  
  group_by(state, year, weeks_left, party) |>
  summarize(avg_support = mean(poll_support), .groups = "drop") |>
  
  pivot_wider(names_from = party, values_from = avg_support, names_prefix = "support_") |>
  
  mutate(
    margin = support_DEM - support_REP
  ) |>
  
  pivot_wider(
    names_from = weeks_left, 
    values_from = c(support_DEM, support_REP, margin)
  ) |>
  
  mutate(
    polling_trend_5_1 = margin_1 - margin_5,
    polling_trend_10_6 = margin_6 - margin_10,
    average_polling = rowMeans(across(starts_with("margin_")), na.rm = TRUE),
    current_week = margin_1
  ) |>
  
  na.omit() |>
  
  select(year, state, support_DEM_1,support_DEM_3, support_DEM_2,support_REP_1, polling_trend_5_1, polling_trend_10_6, average_polling, current_week)

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
state_dpi <- read_csv("Table.csv") 
state_dpi[, 28:77] <- lapply(state_dpi[, 28:77], as.numeric)
state_dpi <- state_dpi %>% select(-c(3:27))
state_dpi <- state_dpi |> 
  mutate(state = GeoName) |>
  select(-GeoName, -GeoFips) 

```


```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_state_dpi <- state_dpi |>
  filter(state %in% swing_states) |>
  pivot_longer(cols = `1974`:`2023`, names_to = "year", values_to = "percent_change_dpi") |>
  mutate(year = as.numeric(year)) |>
  mutate(election_year = year + 1) |>
  filter(election_year %% 4 == 0) |>
  select(-year) |>
  rename(year = election_year) 
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
yearly_inflation <- read_csv("yearly_inflation.csv")
yearly_inflation <- yearly_inflation |> 
  select(-c(1:4)) |>
  pivot_longer(cols = 1:64, names_to = "year", values_to = "yearly_national_inflation")

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
yearly_inflation <- yearly_inflation |> 
  mutate(year = as.numeric(year)) |>
  mutate(year = year + 1) |>
  mutate(yearly_national_inflation = as.numeric(yearly_national_inflation)) 
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_dpi<- swing_state_dpi |>
  left_join(yearly_inflation, by = "year") |>
  mutate(dpi_inflation_adjusted = percent_change_dpi - yearly_national_inflation) |>
  select(-percent_change_dpi, -yearly_national_inflation)
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_data <- swing_state_polls_dem |>
  left_join(swing_state_dpi, by = c("year","state")) |>
  na.omit()
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
state_pop_vote <- read_csv("state_popvote_1948_2020.csv") 
state_pop_vote_dem <- state_pop_vote |>
  filter(state %in% swing_states) |>
  select(c( year, state,D_pv2p, D_pv2p_lag1, D_pv2p_lag2)) 

  
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_data <- swing_state_data |>
  left_join(state_pop_vote_dem, by = c("year", "state"))
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
nat_pop_vote <- read_csv("popvote_1948_2020.csv") |>
  filter(party == "democrat") |> 
  select(year, incumbent_party) |>
  mutate(incumbent_party = ifelse(incumbent_party == TRUE, 1, 0))
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_data <- swing_state_data |>
  left_join(nat_pop_vote, by = "year")
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
fred_econ <- read_csv("fred_econ.csv") 
fred_adjusted <- fred_econ |>
  filter(year > 1958) |>
  mutate(unemployment_growth_quarterly = (unemployment - lag(unemployment, 1)) / lag(unemployment, 1) * 100) |>
  filter(quarter == 2) |>
  mutate(sp500_growth_quarterly = ((sp500_adj_close - sp500_open)) / sp500_open * 100) |>
  filter(year >= 1960)
         
data_2020 <- fred_adjusted |>
  filter(year == 2020 | year == 2019) |>
  mutate(RDPI_growth_quarterly =  lag(RDPI_growth_quarterly, 1), unemployment_growth_quarterly =  lag(unemployment_growth_quarterly, 1)) |>
  filter(year == 2020)

fred_adjusted <- fred_adjusted |>
  filter(year != 2020) |>
  bind_rows(data_2020) |>
  filter(year %% 4 == 0) |>
  select(year, RDPI_growth_quarterly,sp500_growth_quarterly, unemployment_growth_quarterly) 

```


```{r , echo= FALSE, message = FALSE, warning=FALSE}
 swing_state_data <-  swing_state_data |>
  left_join(fred_adjusted, by = "year")
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
updated_rdpi <- read.csv("DSPIC96.csv")

updated_rdpi$DATE <- as.Date(updated_rdpi$DATE, format = "%m/%d/%Y")

updated_rdpi$Year <- format(updated_rdpi$DATE, "%Y")
updated_rdpi$Month <- format(updated_rdpi$DATE, "%B")  # %B for full month name

updated_rdpi <- updated_rdpi[, !(names(updated_rdpi) %in% "DATE")]

updated_rdpi <- updated_rdpi %>%
  mutate(Year = as.numeric(Year)) %>% 
  filter((Month == "June" | Month == "September") & Year %% 4 == 0) %>%
  group_by(Year) %>% 
  pivot_wider(names_from = Month, values_from = DSPIC96) %>%
  ungroup() %>%
  mutate(updated_rdpi = ((September - June) / June) * 100) |> 
  mutate(year = Year) |>
  select(year,updated_rdpi )

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
swing_state_data <-  swing_state_data |>
  left_join(updated_rdpi, by = "year") |>
  filter(year != 1976)
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
twentyfour_lags <- state_pop_vote |>
  filter(year == 2020) |>
   mutate(D_pv2p_lag2= D_pv2p_lag1,
     D_pv2p_lag1 = D_pv2p,
     year = 2024) |>
  select(-D_pv2p)

swing_state_data_test <- swing_state_data |>
  filter(year == 2024) |>
  select(where(~ !all(is.na(.)))) |>
  left_join(twentyfour_lags, by = c("state", "year")) 
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

state_weights <- list()
predictions_2024 <- list()


c <- 3  

for (state_name in swing_states) {
  
 # print(state_name)
  
  
  n_state_data <- swing_state_data |>
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == state_name) |>
    filter(year != 2024)
  
  state_data <- n_state_data |>
    filter(state != "AAFlorida")
  
  fl_data <- n_state_data |>
    filter(state == "AAFlorida")
  
  individual_predictions <- matrix(NA, nrow = nrow(state_data), ncol = c)
  true_values <- state_data$D_pv2p
  
  
  for (i in 1:nrow(state_data)) {
    
    d_train_data <- state_data[-i, ]
    d_test_data <- state_data[i, , drop = FALSE]
    
    #print(d_test_data$state)
    #print(d_test_data$year)
    #print(d_test_data$D_pv2p)
    
    test_year <- d_test_data$year
    
    train_data <- bind_rows(d_train_data, fl_data) |>
      filter(year != test_year )
    
    
    test_data <- bind_rows(d_test_data, fl_data) |>
      filter(year == test_year)  |>
      arrange(desc(state == "AAFlorida"))
  
 
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = train_data)
      
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = train_data)
    
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1  + D_pv2p_lag2 + support_DEM_1 +  polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = train_data)
    
    
    individual_predictions[i, 1] <- predict(mod_1, newdata = test_data)[2]
    individual_predictions[i, 2] <- predict(mod_2, newdata = test_data)[2]
    individual_predictions[i, 3] <- predict(mod_3, newdata = test_data)[2]
    
    #print(individual_predictions[i, ])
    
    
  }
  
  
  train_data <- swing_state_data |> 
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == state_name) |>
    filter(year != 2024)
  
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = train_data)
      
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = train_data)
    
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1  + D_pv2p_lag2 + support_DEM_1 +  polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = train_data)
    
  
  
  y_test <- true_values
  
  w <- lm(y_test ~ individual_predictions - 1) 
  
  initial_weights <- coef(w)
  
  beta <- Variable(c)  
  objective <- Minimize(sum_squares(y_test - individual_predictions %*% beta))
  
  prob <- Problem(objective)
  constraints(prob) <- list(beta >= 0, beta <= 1, sum(beta) == 1)  
  solution_prob <- solve(prob)
  weights_dem <- solution_prob$getValue(beta)
  
  #print(weights_dem)
  
  
  state_weights[[state_name]] <- weights_dem
  
  state_test_data_2024 <- swing_state_data_test |>
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == state_name) |> 
    arrange(desc(state == "AAFlorida"))
  
  pred_1_2024 <- as.numeric(predict(mod_1, newdata = state_test_data_2024))
  pred_2_2024 <- as.numeric(predict(mod_2, newdata = state_test_data_2024))
  pred_3_2024 <- as.numeric(predict(mod_3, newdata = state_test_data_2024))
  
  predictions_matrix_2024 <- cbind(pred_1_2024, pred_2_2024, pred_3_2024)
  #print(predictions_matrix_2024)
  
  weights_dem <- state_weights[[state_name]]
  prediction_2024 <- as.vector(predictions_matrix_2024[2, ] %*% weights_dem)
  
  predictions_2024[[state_name]] <- data.frame(state = state_name, prediction_2024 = prediction_2024)
}

predictions_2024_df <- do.call(rbind, predictions_2024)
#predictions_2024_df

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
weights_df <- do.call(rbind, lapply(swing_states, function(state_name) {
  data.frame(
    State = state_name,
    `Weight Model 1` = state_weights[[state_name]][1],
    `Weight Model 2` = state_weights[[state_name]][2],
    `Weight Model 3` = state_weights[[state_name]][3]
  )
}))

# Display the table using kable for nicely formatted output
weights <- weights_df %>%
  kable("html", caption = "Model Weights by State", digits = 4) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  column_spec(1, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(2:4, width = "6em", extra_css = "text-align: center;")
```


```{r , echo= FALSE, message = FALSE, warning=FALSE}
mse_results <- list()
predicted_vote_shares <- list()
true_vote_shares <- list()

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

for (i in swing_states) {

  train_data <- swing_state_data |> 
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == i) |>
    filter(year != 2024)
  
  state_test_data_2020 <- swing_state_data |>
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == i) |>
    filter(year == 2020)
  
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = train_data)
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = train_data)
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + support_DEM_1 + polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = train_data)
  
  pred_1 <- as.numeric(predict(mod_1, newdata = state_test_data_2020))[2]
  pred_2 <- as.numeric(predict(mod_2, newdata = state_test_data_2020))[2]
  pred_3 <- as.numeric(predict(mod_3, newdata = state_test_data_2020))[2]
  
  predictions <- cbind(pred_1, pred_2, pred_3)
  weights_dem <- state_weights[[i]]
  prediction_dem <- as.vector(predictions %*% weights_dem)
  
  state_test_data_2020 <- state_test_data_2020 |>
    filter(state == i)
  
  rmse_dem_1 <- sqrt(mean((state_test_data_2020$D_pv2p - prediction_dem)^2))
  
  mse_results[[i]] <- rmse_dem_1
  predicted_vote_shares[[i]] <- prediction_dem
  true_vote_shares[[i]] <- state_test_data_2020$D_pv2p
}

rmse_df <- data.frame(
  State = names(mse_results),
  `RMSE 2020` = unlist(mse_results),
  `Predicted Vote Share` = unlist(predicted_vote_shares),
  `True Vote Share` = unlist(true_vote_shares)
)

# Display the table using kable for nicely formatted output
in_rmse <- rmse_df %>%
  kable("html", caption = "In-Sample RMSE for 2020 by State", row.names = FALSE, digits = 4) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  column_spec(1, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(2, width = "6em", extra_css = "text-align: center;") %>%
  column_spec(3, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(4, width = "8em", extra_css = "text-align: center;")


```


```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

rmse_results <- list()
predicted_vote_shares <- list()
true_vote_shares <- list()

for (i in swing_states) {

  train_data <- swing_state_data |> 
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == i) |>
    filter(year != 2020 & year != 2024)
  
  state_test_data_2020 <- swing_state_data |>
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == i) |>
    filter(year == 2020)
  
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party, data = train_data)
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = train_data)
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + support_DEM_1 + polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = train_data)
  
  pred_1 <- as.numeric(predict(mod_1, newdata = state_test_data_2020))[2]
  pred_2 <- as.numeric(predict(mod_2, newdata = state_test_data_2020))[2]
  pred_3 <- as.numeric(predict(mod_3, newdata = state_test_data_2020))[2]
  
  predictions <- cbind(pred_1, pred_2, pred_3)
  weights_dem <- state_weights[[i]]
  prediction_dem <- as.vector(predictions %*% weights_dem)
  
  state_test_data_2020 <- state_test_data_2020 |>
    filter(state == i)
  
  rmse_dem_1 <- sqrt(mean((state_test_data_2020$D_pv2p - prediction_dem)^2))
  
  rmse_results[[i]] <- rmse_dem_1
  predicted_vote_shares[[i]] <- prediction_dem
  true_vote_shares[[i]] <- state_test_data_2020$D_pv2p
}

rmse_df <- data.frame(
  State = names(rmse_results),
  `RMSE 2020` = unlist(rmse_results),
  `Predicted Vote Share` = unlist(predicted_vote_shares),
  `True Vote Share` = unlist(true_vote_shares)
)

# Display the table using kable for nicely formatted output
out_rmse <- rmse_df %>%
  kable("html", caption = "Out-of-Sample RMSE for 2020 by State", row.names = FALSE, digits = 4) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  column_spec(1, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(2, width = "6em", extra_css = "text-align: center;") %>%
  column_spec(3, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(4, width = "8em", extra_css = "text-align: center;")
```



```{r , echo= FALSE, message = FALSE, warning=FALSE}

state_pop_vote_1 <- state_pop_vote |>
  filter(state != swing_states & year == 2020) |>
  mutate(margin = D_pv2p - R_pv2p) |>
  select(state, margin) 

ensemble_pred <- predictions_2024_df |>
  mutate(adj_dem_vote = prediction_2024,
         adj_rep_vote = 100 - prediction_2024,
         Margin = adj_dem_vote - adj_rep_vote,
         sum = adj_dem_vote + adj_rep_vote) |>
  filter(state %in% swing_states) |>
  select(state,Margin) 

 ensemble_pred_table <- ensemble_pred %>%
  mutate(Margin = paste0(round(Margin, 2), "%")) %>%   
  rename(State = state)  


e_pred <- ensemble_pred_table %>%
  select(State, Margin) %>%
  kable("html", caption = "Ensemble Model Predicted Vote Share", row.names = FALSE) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  column_spec(1, width = "8em", extra_css = "text-align: center;") %>%
  column_spec(2, width = "8em", extra_css = "text-align: center;")



pred_2024 <- bind_rows(ensemble_pred, state_pop_vote_1)
  
#write_csv(pred_2024, "avi_2024_pred.csv")

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_state_data_dems <- ensemble_pred %>%
  mutate(state = tolower(state)) 

us_states <- map_data("state")


swing_map_data <- us_states %>%
  filter(region %in% swing_state_data_dems$state) %>%
  left_join(swing_state_data_dems, by = c("region" = "state"))

swing_map_data <- swing_map_data %>%
  distinct(region, .keep_all = TRUE) %>%
  mutate(state = tools::toTitleCase(region)) %>%
  mutate(state_code = state.abb[match(state, state.name)]) |>
  mutate(region = tools::toTitleCase(region))

map_plot <- plot_ly(
  data = swing_map_data,
  type = "choropleth",
  locations = ~state_code,
  locationmode = "USA-states",
  z = ~Margin,
  text = ~paste("State:", region, "<br>Margin:", round(Margin, 2), "%"),
  hoverinfo = "text",
  colorscale = list(c(0, "darkred"), c(0.5, "white"), c(1, "blue")),
  zmin = -10,   
  zmid = 0,     
  zmax = 10,    
  colorbar = list(
    title = "Dem. Voting Margin (%)",
    y = 0.5,           
    yanchor = "middle" 
  )
) %>%
  layout(
    title = list(
      text = "2024 Swing State Voting Margins",
      y = 0.95,
      x = 0.5,
      xanchor = "center",
      yanchor = "top"
    ),
    geo = list(
      scope = "usa",
      projection = list(type = "albers usa"),
      showlakes = FALSE,
      showcountries = FALSE,
      showcoastlines = FALSE,
      coastlinecolor = toRGB("white"),
      showframe = FALSE
    )
  )
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

num_samples <- 1000

swing_state_polls_dem <- swing_state_polls |>
  filter(state %in% swing_states & weeks_left < 11 & weeks_left >= 1) |>
  
  group_by(state, year, weeks_left, party) |>
  summarize(avg_support = mean(poll_support), .groups = "drop") |>
  
  pivot_wider(names_from = party, values_from = avg_support, names_prefix = "support_") |>
  
  mutate(
    margin = support_DEM - support_REP
  ) |>
  
  pivot_wider(
    names_from = weeks_left, 
    values_from = c(support_DEM, support_REP, margin)
  ) |>
  
  mutate(
    polling_trend_5_1 = margin_1 - margin_5,
    polling_trend_10_6 = margin_6 - margin_10,
    average_polling = rowMeans(across(starts_with("margin_")), na.rm = TRUE),
    current_week = margin_1
  ) |>
  
  na.omit() 


swing_state_data_sim <- swing_state_polls_dem %>%
  filter(year == 2024) %>%
  group_by(state) %>%
  summarize(
    polling_trend_5_1_mean = mean(polling_trend_5_1),
    polling_trend_10_6_mean = mean(polling_trend_10_6),
    current_week_mean = mean(current_week),
    support_DEM_1_mean = mean(support_DEM_1),
    support_DEM_2_mean = mean(support_DEM_2),
    support_DEM_3_mean = mean(support_DEM_3),
    support_REP_1_mean = mean(support_REP_1),
    .groups = 'drop'
  )

polling_error_sd <- 3


simulated_data <- swing_state_data_sim %>%
  rowwise() %>%
  mutate(
    polling_trend_5_1_sim = list(rnorm(num_samples, mean = polling_trend_5_1_mean, sd = polling_error_sd)),
    polling_trend_10_6_sim = list(rnorm(num_samples, mean = polling_trend_10_6_mean, sd = polling_error_sd)),
    current_week_sim = list(rnorm(num_samples, mean = current_week_mean, sd = polling_error_sd)),
    support_DEM_1_sim = list(rnorm(num_samples, mean = support_DEM_1_mean, sd = polling_error_sd)),
    support_DEM_2_sim = list(rnorm(num_samples, mean = support_DEM_2_mean, sd = polling_error_sd)),
    support_DEM_3_sim = list(rnorm(num_samples, mean = support_DEM_3_mean, sd = polling_error_sd)),
    support_REP_1_sim = list(rnorm(num_samples, mean = support_REP_1_mean, sd = polling_error_sd))
  ) %>%
  unnest(c(polling_trend_5_1_sim, polling_trend_10_6_sim, current_week_sim, support_DEM_1_sim, support_REP_1_sim)) |>
  rename(
    polling_trend_5_1 = polling_trend_5_1_sim,
    polling_trend_10_6 = polling_trend_10_6_sim,
    current_week = current_week_sim,
    support_DEM_1 = support_DEM_1_sim,
    support_DEM_2 = support_DEM_2_sim,
    support_DEM_3 = support_DEM_3_sim,
    support_REP_1 = support_REP_1_sim
  ) |>
  mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
  select(state, polling_trend_5_1, polling_trend_10_6, current_week, support_DEM_1, support_REP_1)

```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
num_simulations <- 1000

simulation_results <- list()

swing_states <- c("Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin")

electoral_votes <- c("Arizona" = 11, "Georgia" = 16, "Michigan" = 15, 
                     "Nevada" = 6, "North Carolina" = 16, "Pennsylvania" = 19, "Wisconsin" = 10, 
                     "AAFlorida" = 0) #assuming dems. never win FL

base_electoral_votes <- 226

total_electoral_votes <- numeric(num_simulations)  


for (state_name in swing_states) {
  
  state_data <- swing_state_data |> 
    mutate(state = ifelse(state == "Florida", "AAFlorida", state)) |>
    filter(state == "AAFlorida" | state == state_name) |>
    filter(year != 2024)
  
  mod_1 <- lm(D_pv2p ~ state + D_pv2p_lag1 + D_pv2p_lag2 + updated_rdpi*incumbent_party + dpi_inflation_adjusted*incumbent_party,  data = state_data)
      
  mod_2 <- lm(D_pv2p ~ state + polling_trend_5_1 + polling_trend_10_6 + current_week + support_DEM_1 + support_DEM_2 + support_DEM_3, data = state_data)
    
  mod_3 <- lm(D_pv2p ~ state + D_pv2p_lag1  + D_pv2p_lag2 + support_DEM_1 +  polling_trend_5_1 + polling_trend_10_6 + dpi_inflation_adjusted*incumbent_party + unemployment_growth_quarterly*incumbent_party + updated_rdpi*incumbent_party, data = state_data)
  
  fl_state_data <- swing_state_data_test |>
    filter(state == "Florida") |>
    mutate(state = "AAFlorida")

  for (i in 1:num_simulations) {
    
    sim_poll <- simulated_data %>%
      filter(state == state_name) %>%
      slice(i) %>%
      select(state, polling_trend_5_1, polling_trend_10_6, current_week, support_DEM_1, support_REP_1)
    
  
    state_test_data <- swing_state_data_test |>
      filter(state == state_name) |>
      select(-c(polling_trend_5_1, polling_trend_10_6, current_week, support_DEM_1, support_REP_1))
    
    state_test_data <- state_test_data |>
      left_join(sim_poll, by = "state") 
    
    test_data <- bind_rows(state_test_data, fl_state_data)
    
  
    pred_1 <- predict(mod_1, newdata = test_data)[1]
    pred_2 <- predict(mod_2, newdata = test_data)[1]
    pred_3 <- predict(mod_3, newdata = test_data)[1]
    

    weights_dem <- state_weights[[state_name]]
    prediction <- as.vector(c(pred_1, pred_2, pred_3) %*% weights_dem)

    if (prediction > 50) {
      total_electoral_votes[i] <- total_electoral_votes[i] + electoral_votes[state_name]
    }
  }
}


total_electoral_votes <- total_electoral_votes + base_electoral_votes


electoral_vote_counts <- table(total_electoral_votes)

electoral_vote_df <- data.frame(
  electoral_votes = as.numeric(names(electoral_vote_counts)),
  count = as.numeric(electoral_vote_counts)
)


```

```{r , echo= FALSE, message = FALSE, warning=FALSE}
expanded_data <- electoral_vote_df %>%
  mutate(count = round(count * 0.2)) %>%  
  uncount(count) %>% 
  mutate(color = ifelse(electoral_votes >= 270, "steelblue", "red"))


sim_plot <- ggplot(expanded_data, aes(x = electoral_votes, fill = color)) +
  geom_dotplot(binwidth = 3, dotsize = 0.5, stackdir = "up", stroke = 0) +
  scale_x_continuous(breaks = seq(0, 538, by = 10), limits = c(220, 310)) +
  scale_fill_identity() + 
  labs(
    title = "Simulated Electoral College Outcomes",
    subtitle = "Each dot represents five simulation results",
    x = "Harris Electoral Vote Total",
    y = "Frequency (stacked dots)"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()
  ) +
  geom_vline(xintercept = 270, color = "black", linetype = "dashed", alpha = 0.7)
```

```{r , echo= FALSE, message = FALSE, warning=FALSE}

total_simulations <- 1000


win_counts <- electoral_vote_df %>%
  filter(electoral_votes >= 270) %>%
  summarize(
    `Harris Victory Wins` = sum(count),
    `Trump Victory Wins` = total_simulations - sum(count),
    `Harris Victory %` = paste0(round((sum(count) / total_simulations) * 100, 2), "%")
  )

sim_table <- win_counts %>%
  kable("html", caption = "Simulation Results: Harris and Trump Victory Counts") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive"), position = "center") %>%
  column_spec(1, width = "5em", extra_css = "text-align: center;") %>%
  column_spec(2, width = "5em", extra_css = "text-align: center;") %>%
  column_spec(3, width = "5em", extra_css = "text-align: center;")

```

# Introduction

This model aims to predict the outcome of the Electoral College, thereby determining the next President of the United States. Consequently, I chose not to predict the national vote share, as it is not irrelevant to the outcome of the election.

As an aside, I strongly believe the Electoral College should be abolished. If you're interested in exploring an innovative proposal on this topic, please read [this article I wrote for the Harvard Political Review](https://www.google.com/url?q=https://theharvardpoliticalreview.com/abolishing-the-electoral-college-might-not-be-as-hard-as-you-think/&sa=D&source=docs&ust=1730744938415047&usg=AOvVaw0DxVlAlSrc9iDKDJnC6FvV).

This model is based on the assumption that only the following states are truly competitive: Arizona, Georgia, Michigan, Nevada, North Carolina, Pennsylvania, and Wisconsin. I identified these states as battlegrounds in my [Week #1 Post](https://www.google.com/url?q=https://aviagarwal27.github.io/election-blog/post/2024/09/09/post-1/&sa=D&source=docs&ust=1730744938419669&usg=AOvVaw396BBePF9Prpw5Quf-SVqp), an assessment shared by other experts such as the [Cook Political Report](https://www.google.com/url?q=https://www.cookpolitical.com/ratings/presidential-race-ratings&sa=D&source=docs&ust=1730744938420324&usg=AOvVaw3bqDvDo0UMv4WgnsBToQEc). Therefore, this model will focus exclusively on predicting the two-party vote share in these seven states, assuming an initial distribution of electoral votes where Harris holds 226 and Trump holds 219.

Given the volume of polls that only display these states as toss-ups, I am confident in this assumption. However, [a recent poll by Selzer & Co.](https://www.google.com/url?q=https://www.economist.com/united-states/2024/11/03/a-much-watched-poll-from-iowa-points-to-a-harris-landslide&sa=D&source=docs&ust=1730744938416006&usg=AOvVaw02ROEOOtCjGOG9ISwsKd7_)—a highly respected pollster—found Harris leading by 3 points in Iowa, a state Trump won by 8 points in 2020. If accurate, this poll could challenge the model's assumptions and potentially signal a landslide Harris electoral college victory, exceeding the model's maximum of 319 electoral votes.


# Model Equations

For this model, I wanted to balance the effects of fundamentals and polling based on historical election outcomes to increase the predictive accuracy of my model. Given this, I chose to use a super-learning model ensembling method predicting the expected vote share with three distinct Ordinary Least Square (OLS) models and then combining them using empirically generated weights.

Initially, I had created one set of weights I had used for all the swing states, but I soon realized that having individual weights for each state would lead to lower RMSE. As a result, I chose to loop the swing states and create separate models using Florida as an intercept. Since I created three individual models for each state or 21 models in total, I chose not to include the summaries of the coefficients.

I used data from the 1980 - 2020 elections to train the models, the largest range where all data was available. 


**Model 1:**

  $$
\begin{aligned}
D\_pv2p = & \, \alpha + \beta_1(\text{state}) + \beta_2(\text{D\_pv2p\_lag1}) + \beta_3(\text{D\_pv2p\_lag2}) \\
& + \beta_4(\text{updated\_rdpi} \times \text{incumbent\_party}) + \beta_5(\text{dpi\_inflation\_adjusted} \times \text{incumbent\_party}) + \epsilon
\end{aligned}
  $$

The first model uses only fundamental predictors, including lagged Democratic two-party vote shares from 2016 and 2020 and two measures of Real Disposable Personal Income (RDPI). 

The first RDPI measure, "updated RDPI," is the most recent national RDPI data available, covering June 1 to September 1 of the election year (between Q2 and Q3). This data is sourced from [the Federal Reserve Bank of St. Louis](https://www.google.com/url?q=https://fred.stlouisfed.org/&sa=D&source=docs&ust=1730744938416565&usg=AOvVaw25h3mQydPwVYzl7WAQtJHK). To avoid the economic impact of the COVID-19 pandemic on 2020 data, I used the [Congressional Budget Office](https://www.google.com/url?q=https://www.cbo.gov/data/budget-economic-data&sa=D&source=docs&ust=1730744938417175&usg=AOvVaw2FKA59eQxjB1eMN60eNEcj)’s 2020 RDPI growth projections rather than actual values.

The second RDPI measure, "DPI inflation-adjusted," uses state-level disposable income data from the [Bureau of Economic Analysis](https://www.google.com/url?q=https://www.bea.gov/data&sa=D&source=docs&ust=1730744938417709&usg=AOvVaw0qAVTfeqQsGNBAii-wnssN), adjusted for inflation with World Bank data. Since quarterly state-level DPI is unavailable for 2024, I used data from the year preceding the election. 

Both economic variables are modeled as interaction effects, with a binary variable indicating the incumbent party. Including both state and national predictors helps capture voter perceptions of national economic conditions and personal financial situations.



**Model 2:**

  $$
\begin{aligned}
D\_pv2p = & \, \alpha + \beta_1(\text{state}) + \beta_2(\text{polling\_trend\_5\_1}) + \beta_3(\text{polling\_trend\_10\_6}) \\
& + \beta_4(\text{current\_week}) + \beta_5(\text{support\_DEM\_1}) + \beta_6(\text{support\_DEM\_2}) + \beta_7(\text{support\_DEM\_3}) + \epsilon
\end{aligned}
  $$

The second model relies solely on various polling-based covariates, all sourced from [FiveThirtyEight](https://www.google.com/url?q=https://projects.fivethirtyeight.com/polls/&sa=D&source=docs&ust=1730744938418979&usg=AOvVaw3PPYvini-EY-MVTfSMOHoj) with their poll weighting applied. The data is state-level and grouped by the weeks remaining before the election.

The first three polling variables—Polling Trend 5-1, Polling Trend 6-10, and Current Week—are measured in poll margin (Democratic candidate polling minus Republican candidate polling). Polling Trend 5-1 captures the change in margin from five weeks to one week before the election, indicating whether a candidate is gaining or losing ground close to Election Day. Polling Trend 6-10 reflects changes from six to ten weeks out, while Current Week is the margin from one week before the election.

The last three variables—Support Dem. 1, Support Dem. 2, and Support Dem. 3—represent the average Democratic candidate polling one, two, and three weeks before the election, respectively.




**Model 3:**

  $$
\begin{aligned}
D\_pv2p = & \, \alpha + \beta_1(\text{state}) + \beta_2(\text{D\_pv2p\_lag1}) + \beta_3(\text{D\_pv2p\_lag2}) + \beta_4(\text{support\_DEM\_1}) \\
& + \beta_5(\text{polling\_trend\_5\_1}) + \beta_6(\text{polling\_trend\_10\_6}) + \beta_7(\text{dpi\_inflation\_adjusted} \times \text{incumbent\_party}) \\
& + \beta_8(\text{unemployment\_growth\_quarterly} \times \text{incumbent\_party}) + \beta_9(\text{updated\_rdpi} \times \text{incumbent\_party}) + \epsilon
\end{aligned}
  $$

The third model combines Models 1 and 2 covariates with the addition of national-level Q2 unemployment growth from the Fed. in St. Louis, which is included as an interaction effect with the incumbent party. Including this factor reduced the RMSE, which led me to incorporate it in this combined model.



# Weights

To generate weights without excluding election cycles and reduce overfitting concerns from training on a single election, I used a Leave-One-Out scheme where I trained all three models, excluding one election cycle at a time, and then predicted the results for the excluded election. 

After repeating this process for each election in the dataset, I performed a constrained optimization with a Beta between 0 and 1 using the three predicted values (each from one of the above models) and the actual vote share to generate the individual state weights. Table 1 below displays the resulting weights for each state.


```{r , echo= FALSE, message = FALSE, warning=FALSE}
weights

```

The second model, which relies solely on polling data, consistently receives the highest weight. In states like Arizona and Pennsylvania, its weight comprises nearly the entire model, while in Michigan and Nevada, it is slightly above 0.5. 

The fundamental model is weighted just above 0.1 in four swing states, reaching nearly 0.4 in North Carolina and dips to a low in Pennsylvania and Arizona. Model 3, the combined model, shows the greatest variance, with weights close to zero in some states and over 0.2 in others. Overall, the weights clearly vary significantly depending on the state.


# RMSE (In-sample & Out-of-sample)

To test the predictive accuracy of this model, I calculated both in-sample and out-of-sample root mean square error (RMSE) based on the 2020 election. For the in-sample RMSE, I included 2020 data in the training set while using the same weights derived from all prior elections. For the out-of-sample RMSE, I excluded the 2020 data from the training set, but still applied the same weights. Although this means the out-of-sample RMSE reflects weights partially trained on 2020 data, removing this data would be challenging given the method I used for generating the weights, and the impact of any single election on weight determination is minimal.

The in-sample RMSE results, in Table 2, were encouraging, ranging from a low of 0.04 in Georgia to a high of 2.05 in Wisconsin, indicating that the maximum prediction error was within 2 percentage points—enough to potentially swing a state. Most of the error came from overestimating the Democratic vote share.

```{r , echo= FALSE, message = FALSE, warning=FALSE}
in_rmse
```

The out-of-sample RMSE results, while expectedly higher, remained strong. The highest RMSE was in Pennsylvania at 2.46, due to a significant overestimation of the Democratic vote share. This is likely due to the model’s reliance on polling data for Pennsylvania, as shown in Table 1, where polling errors led to an overestimate.

```{r , echo= FALSE, message = FALSE, warning=FALSE}
out_rmse
```



# Ensemble Model Predictions

Now, with the preamble complete, we can finally reach the main event: Who will win the 2024 Presidential Election?

Using data from 2024, my model predicts that Harris will narrowly win in Pennsylvania and Wisconsin, with more substantial leads in Michigan and Nevada—enough to reach 270 electoral votes and become **America’s 47th President**. She is projected to lose Arizona by a large margin, with close losses in both North Carolina and Georgia, finishing with 276 electoral votes to Trump’s 262.

```{r , echo= FALSE, message = FALSE, warning=FALSE}
e_pred
```
You can view the margins in Table 4 above or by hovering over the states in the interactive map below   .



```{r , echo= FALSE, message = FALSE, warning=FALSE}
map_plot
```

# Simulations

However, even if my model were 100% accurate, these predictions would only hold if polling error were zero. As we saw in 2016 and 2020, polling errors can be significant, sometimes even reversing expectations entirely, as in 2016.

To account for this, I ran 1,000 simulations of all polling-based covariates, using a normal distribution centered around the mean with a standard deviation of 3. I then predicted Harris’s total electoral vote share in all 1,000 simulations to estimate her likelihood of winning the election.

The plot below represents the distribution of these simulations, with each dot representing five simulations. Harris victories are shown in blue, while losses are shown in red. As you can see, the majority of simulations predict a Harris victory, with the most common outcome being Harris achieving 276 electoral votes, the scenario predicted above. As expected, the most common loss scenario is when Harris earns only 257 electoral votes, primarily from losing Pennsylvania.

Table 5 below shows that, out of the 1,000 simulations, Harris wins in 589 and loses in 411.

```{r , echo= FALSE, message = FALSE, warning=FALSE}
sim_plot
```


```{r , echo= FALSE, message = FALSE, warning=FALSE}
sim_table
```

# Conclusion & Acknowledgements

Overall, my model suggests that Harris has a **slightly higher chance of winning the election**, but ultimately, the race is still a toss-up and far too close to call.

In closing, I would like to acknowledge the exceptional faculty and course staff of Gov 1347: Election Analytics, without whose teaching and guidance this project would not have been possible: Professor Ryan Enos, Teaching Fellow Matthew Dardet, and Course Assistants Ethan Jasney and Yusuf Mian.

Thank you for reading, and I hope you enjoyed this analysis! If you have any questions or feedback, please feel free to reach out to me at *aviagarwal@college.harvard.edu*.